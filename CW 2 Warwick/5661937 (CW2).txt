Feedback for student 5661937 for coursework 2 of CS118
General Feedback:

Overall, this coursework was handled well by the majority, with the average mark being 695.
Roughly 5% of students have achieved a mark between 50 and 60.
Roughly 26% of students have achieved a mark between 60 and 70.
Roughly 39% of students have achieved a mark of 70 or higher.
Roughly 16% of students achieved a mark of 80 or higher. 
Roughly 2% of students achieved a mark of 90 or higher.


A number of people still used the hard-coded values represented by the ENUMS - despite being warned to not do so.
Another similar issue included students clearly not testing their solution on the DCS machines, as they have used the incorrect JDK.
Exercise 1 had many areas where the code could be improved.
Junctions and crossroads could be handled within the same method.
You can also make a generic method for counting the different types of spaces - many people made several methods that are exactly the same.
Instead, consider making a method that takes a type of square as a parameter, and then counts that type of square.
Many people did not use dynamic data types, such as making use of an array list or a stack object.
The best method for storing junction information is to make a junctionRecorder type object and store an arraylist (or consider how to re-size the array) or stack of them.

Exercise 2 required a stack-based approach, some solutions kept storing X and Y.
Some students used an array like a stack, but the best approach is to either build the full data structure or use java's implementation.
Exercise 3 could be completed using a single if-statement. It just required turning around if encountering a beenbefore in explore mode.
A more complex solution was also viable, and generally, if the robot performed a systematic search, a good mark for exercise 3 was achieved.
A few solutions relied too much on random behaviour - if the robot was surrounded by been befores it might fall back on random behaviour. 
This is unneeded, a proper approach can still systematically search the maze and find a route.

A common issue in the grand finale was not accounting for the robot starting in a corridor.
This can lead to anything from a minor issue (the robot going doing a single dead end at the start) or a major problem (such as collisions).
Some robots could only do two runs, the learning run and the perfect run. Any further attempts would break.
The best robots were capable of multiple perfect runs in a row, as well as learning a new maze without resetting the environment.
Some solutions implemented a homing style of search in the first run, which is a good improvement.
Despite discussion and clarification in the lectures, some robots learned over multiple runs, even in prim mazes. 
There were good approachs to loopy mazes, with many robots being able to solve loopy mazes, even if not optimally.
Some solutons were over engineered, despite warnings of avoiding this. There is minimal need for a larger number of utility classes and wrappers, as these can obscure functionality.
Many solutions still lacked sufficient commenting and style.
Even with substantial preambles - comments and javadocs should be provided to give context and direction to code.
This is particularly true for the grand finale, where complex code blocks should be explained.


A small number of students may experience an issue with their comments, due to a sitebuilder issue that could not be solved. If you feel your feedback is lacking, or absent, and you feel that the above does not cover what you need to know, please email me and I will provide additional feedback as needed. 

Exercise 1:
	Utility methods : 1st
	Junction data storage : 2:1
	Explorer/Backtrack controls : 2:2
	Complexity analysis : 2:2
	Software engineering : 1st
	Ex 1 Mark : 65
	No location storage : Sensible reduction of redundant utility methods. The design of RobotData could be better. Could have used dynamic data types. Exploring and backtracking are not correctly implemented. Poor/No understanding of worst-case analysis. Needed to discuss the different types of space and how many times you would encounter each one. Code is very modular. Good code structure/style. More appropriate documentation (in comments) is encouraged.

Exercises 2 & 3:
	No location storage : 2:1
	Loopy mazes : 2:2
	Ex 2 Mark : 59
	Explorer 2 and 3 Comments : Correct implementation of stack-based junction storage. Good use of stack object. Solution solves mazes but falls back to random when in loops. Good code structure/style. Code could be improved with better documentation  perhaps Javadoc-style comments.

Grand Finale:
	Systematic search : 2:1
	Solves mazes perfectly : High 1st
	Solves loopy mazes : 2:1
	Style/Documentation : 1st
	Design/Modularity/Engineering : 2:1
	GF Mark : 76
	GrandFinale Comments : Good systematic search as in Exercise 1. Solves mazes perfectly on second run  even if robot starts in a corridor. Solution solves loopy mazes but not optimally. Solution does not solve loopy mazes. Good code structure/style. The code could be better documented using Javadoc-style comments. OK designed GrandFinale solution. GrandFinale is modular.

 Final Mark / 100: 68
